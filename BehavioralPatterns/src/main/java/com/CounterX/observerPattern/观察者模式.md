# 观察者模式

观察者模式（Observer）通过实现一种通知机制，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

这种通知机制，类似于线程调度中的 `notifyAll()` ，严格来说，线程调度也应用了观察者模式：锁的 `Monitor` 就是被观察者，而竞争锁的线程就是 `Observer`, 当 `Monitor` 被释放后，通过 `notifyAll` 唤醒所有竞争锁的线程，并进行锁的竞争。

### 示例

观察者模式应用更广泛的是发布-订阅模式（Publish-Subscribe：Pub/Sub），即被观察者并不直接通知观察者，而是通过一个 `EventChannel` 通知所有观察者，这样被观察者和观察者就实现了解耦，被观察者无需知道哪些类在观察它，它只需要知道把 `Event` 放到哪个 `EventChannel` 中就行了。例如下面的 `SubjectImpl` 类。

```java
public class SubjectImpl implements Subject{
    private EventChannel channel;

    @Override
    public void setChannel(EventChannel channel) {
        this.channel = channel;
    }

    @Override
    public void test(String s) {
        // do something
        channel.onEvent(new Event(s));
    }
}
```

`EventChannel` 的实现较为简单，当收到一个事件时，就通知所有注册的观察者。这部分的关键是注册映射关系。

```java
public class EventChannel {
    private final ArrayList<Observer> observers = new ArrayList<>();

    public void registry(Observer observer) {
        observers.add(observer);
    }

    public void onEvent(Event event) {
        observers.forEach((observer -> observer.onEvent(event)));
    }
}
```

观察者 `ObserverImpl` 无需知道事件是如何产生的，只需定义事件产生后做什么就行了。这里是将事件信息输出到命令行。

```java
public class ObserverImpl implements Observer {

    private final String name;

    public ObserverImpl(String name) {
        this.name = name;
    }

    @Override
    public void onEvent(Event event) {
        System.out.println("[Observer " + name + "][recive]" + event);
    }
}
```

如 `ObserverTest` 所示，在使用时，只需先初始化 `EventChannel` (即确定其映射关系)，然后设置其通道。

```java
 @Test
 public void test01() {
     // 初始化 channel
     EventChannel channel = new EventChannel();
     channel.registry(new ObserverImpl("observer1"));
     channel.registry(new ObserverImpl("observer2"));
     channel.registry(new ObserverImpl("observer3"));
     // 调用 subject
     Subject subject = new SubjectImpl();
     subject.setChannel(channel);
     subject.test("test");
 }
```

结果为：

```text
[Observer observer1][recive]Event{time=2022-09-12T22:11:36.016998300, message='test'}
[Observer observer2][recive]Event{time=2022-09-12T22:11:36.016998300, message='test'}
[Observer observer3][recive]Event{time=2022-09-12T22:11:36.016998300, message='test'}
```

### 优缺点

优点： 

1. 在观察者和被观察者之间之间建立了抽象的耦合关系。
2. 如果使用发布-订阅模式，可以降低观察者和被观察者之间的代码的耦合程度，从而将整个过程抽象为三个部分： 
   1. 被观察者只需关心在何种情况下产生事件，使用哪个通道；
   2. 中间的消息系统只需维护被观察者到观察者的消息传输通道的具体映射关系，而不关心二者的具体逻辑；
   3. 观察者只需确定事件发生后的动作，无需关心事件是如何产生的。
3. 观察者模式符合“开闭原则”的要求。

缺点： 

1. 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
2. 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。

### 应用场景

- 线程调度；
- Spring 中的事件机制；
- 消息队列。

# 参考资料

- https://www.liaoxuefeng.com/wiki/1252599548343744/1281319577321505
- https://blog.csdn.net/weixin_44420511/article/details/125263844
- https://blog.csdn.net/weixin_42073629/article/details/106303089