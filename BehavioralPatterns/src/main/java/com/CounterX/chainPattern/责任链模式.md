# 责任链模式

责任链模式是一种行为设计模式，允许将请求沿着处理者组成的链（责任链）进行发送。链上的悲歌处理者在收到请求后，均可对请求进行处理， 或将其传递给链上的下个处理者。

### 优缺点

优点：

1. 将请求与处理进行解耦；
2. 链路中的节点只需要处理自己关心的请求，对于自己不关心的请求放给下一个节点进行处理；
3. 请求不需要知道链路结构，只需要等待链路处理的结果就行了；
4. 链路的结构比较多灵活，可以更改链路的结构，动态的新增删除责任节点，符合开闭原则；

缺点：

1. 责任链太长，或者请求处理的时间太长，会影响整个链路的性能；
2. 如果节点间存在循环引用，会出现死循环，会导致整个系统崩溃。这个缺点可以通过注册表而非直接引用的方式解决。

### 实现方式

实现方式无非两种，通过注册表迭代/递归或者通过直接引用迭代/递归。通过注册表的方法即将所有的处理者注册在注册表中，然后逐个访问。通过直接引用的方法即每个处理者都引用下一个（以及上一个）处理者，然后诸葛访问访问。通过注册表的方法可以避免直接引用方法可能导致的死循环的问题，所以应该尽可能使用通过注册表的方法。

在递归与迭代的方法选择上，迭代相比递归可以节省栈空间，但使用递归调用可以使用 try-catch-finally 很方便地实现 pre-post-after 的三重处理逻辑。由于实例较为简单，这里使用的是注册表迭代的方法。

实现迭代的方法的步骤为：

1. 声明一批处理者 `Processor`;
2. 将所有的处理者 `Processor` 注册到 `Register` 的注册表中（注册表既可以通过 `ArrayList` 实现，也可以通过 `LinkedList` 实现）;
3. 由于 `ArrayList` 和 `LinkedList` 都可以获取双向迭代器 `ListIterator`, 那么通过双向迭代器进行处理即可。

类 `ChainTest` 演示了使用结果和方法

### 应用场景

首先就是当前包中所演示的实现的来源：SpringMVC 拦截器的注册与调用机制。以及类似的 Servlet 框架中的 Filter。进一步地扩展，任何通过代理实现的AOP，都可以把每个切面当做责任链中的处理者，通过责任链模式调用。

# 参考资料

- https://mp.weixin.qq.com/s/ueIrPMalK81sF3sL3WTWTQ
- https://www.liaoxuefeng.com/wiki/1252599548343744/1281319474561057
- https://blog.csdn.net/weixin_44420511/article/details/125293414?spm=1001.2014.3001.5502
- https://blog.csdn.net/tealala/article/details/124772230
