# 单例模式

代码见 `package com.CounterX.singletonPattern`

单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

实现方式：

- 构造方法私有，确保外部无法实例化。
- 通过 `private static` 的属性持有唯一实例，保证全局唯一性。
- 提供 `public static` 的方法接口，使外部调用方能获取实例。

### 实现方式一：饿汉式

见 `Hungry` 类和 `TestHungry` 类

饿汉式方法在类初始化时即实例化对象。这样有很多好处，因而是使用最为广泛的单例模式，其优点有：

1. 无并发问题，在并发情况下可以保证单例特性。
2. 实现简单，代码简洁。
3. 实例属性可以设置为常量，更符合代码规范。

当然，饿汉式方法也有其缺点：

1. 在类加载时即初始化，导致类加载变慢。
2. 如果实例对象占用空间较大又没有使用，会造成资源浪费。
3. 无法防止通过反射破坏单例特性。

然而，这些缺点可以进行规避。例如只加载必须的类，约定用户不使用反射等。

### 实现方式二：懒汉式

见 `Lazy` 类和 `TestLazy` 类

懒汉式的优点在于：

1. 用时加载，减少资源浪费

缺点在于：

1. 线程不安全，在并发环境下初始化会生成多个实例。
2. 无法防止通过反射破坏单例特性。

为了实现线程安全，就需要加锁。

### 实现方式三：双重校验锁的懒汉式单例

见 `DclLazy` 和 `TestDclLazy` 。

双重校验锁（Double-Check Lock, DCL）通过加锁并进行二重验证解决并发问题。其中有3个关键点：

```java
    public static DclLazy getInstance() {
        DclLazy localRef = instance;
        while (localRef == null) {
            synchronized (DclLazy.class) {
                localRef = instance;
                if (localRef == null) {
                    localRef = instance = new DclLazy();
                }
            }
        }
        return localRef;
    }
```

#### 1 为什么使用双重校验

`synchronized` 关键字的作用是加锁，假如线程A、B同时启动、进入循环，A竞争到了锁，那么B就会等待A结束后执行。如果没有双重检验，那么在A实例化结束后，B也会实例化一个对象，从而破坏了单例特性。

#### 2 为什么要引入 `localRef`

因为 `volatile` 关键字在禁止关于 `instance` 的指令重排的同时会导致直接访问 `instance` 的效率下降，通过 `localRef` 间接引用则可以缓解这一问题。

#### 3 为什么要使用 `volatile`

因为 `new` 虽然在JVM看来是原子操作，但在CPU看来却是3条指令：分配空间，初始化空间，将对象指向分配的空间。CPU在执行指令时可能会发生指令重排，从而导致先执行完对象头指向内存空间的指令，而后执行完初始化指令的情况。这种情况下，正在初始化的对象会提前释放锁。这是一种在大并发情况下才偶尔发生的情况，因此很难验证。

### 实现方式四：静态内部类



### 实现方式五：枚举类型



# 结语

#### 如何防止破坏单例模式?

1. 可以增加在构造函数中的检查是否已经实例化，但如果是懒汉式单例，只通过反射创建对象可以破坏单例。
2. 可以使用枚举类型，可以保证在OpenJDK中的单例，但如果对JDK进行修改，依然可以绕过。

#### 代价是什么？

在不断地相互对抗中，代码的复杂程度越来越高（为了防止反射，需要额外的检查），使用起来越来越不方便（使用枚举类型，使用时更不方便）。即使这样，如果刻意想要破坏单例模式，那么终归是能够破坏的，即使是所谓安全的枚举类型也不例外。OpenJDK中的反射机制会禁止通过构造器实例化枚举类型，但这些限制完全可以通过修改JDK来突破。

那么就需要回到初心，问一句为什么需要使用单例模式？

答：为了保证在一个进程中，某个类有且仅有一个实例。这些实例应该能在高并发的实际使用情况中保证单例特性。

在实际使用中会通过反射创建这些类的实例吗？我想是不会的。那么使用饿汉式单例和DCL懒汉式单例就比较合理了，至于以反射机制破坏单例的问题，通过CodeReview解决似乎更加合适。