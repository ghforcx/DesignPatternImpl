# 静态代理模式

以示例说明代理模式的好处：

本示例定义了`Dog`接口，定义了`String getName()`, `void setName(String name)`, `int bark()` 三个方法。

`DogProxy`作为最终代理，被外部函数`Main.main`调用，在以下修改过程中，外部代码无需任何改变。

基础实现类`DogImpl`实现了所有三个方法，测试类`DogImplTest`对这三个方法进行了单元测试。

`DogNameProxy`修改了`bark`方法，增加了没有命名时的结果处理（需要先命名才能叫），测试类`DogNameProxyTest`仅对`bark`方法进行单元测试。将`DogProxy`的父类改为`DogNameProxy`，此过程中，`Main`类和`DogImpl`类均无需任何修改。

`DogLogProxy`修改了所有3个方法，增加了日志输出，测试类`DogLogProxy`对所有三个方法进行了单元测试。将`DogProxy`的父类改为`DogLogProxy`，此过程中，`Main`类、`DogImpl`类和`DogLogProxy`类均无需任何修改。

这样可以得到代理模式的优点：
1. 在对业务逻辑进行修改时无需对原业务代码进行任何修改，从而实现了开闭原则
2. 一个实现类只需实现一种功能，实现了单一职责原则。
3. 每个实现类只实现了一种功能，易于测试。

当然也可以看到其缺点
1. 每增加一个功能就需要多增加一个类，如果一次增加多个功能，就显得繁琐。